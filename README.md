# The-Gaming-Room
This repository contains my completed software design document for The Gaming Room client project. It demonstrates my ability to analyze requirements, document a design, and communicate effectively with clients and development teams. The README includes my reflection on the project and the design process as part of my Computer Science portfolio.

#Reflection

Client and Software Requirements

The client, The Gaming Room, wanted to expand their existing game concept, Draw It or Lose It, into a software application. Their main requirement was to build a scalable, secure, and maintainable design for a game where multiple teams and players could participate. They needed the application to enforce uniqueness of games, teams, and players, while also managing concurrency in a client-server environment.

# What I Did Well
I did particularly well in breaking down the problem into smaller, well-defined design sections. My documentation clearly explained the system architecture, design patterns used, and constraints considered. I was able to highlight the importance of the Singleton pattern for enforcing a single game instance and the Iterator pattern for managing teams and players efficiently.

# Helpful Parts of the Design Process
Working through the design document helped me understand how planning first creates a smoother coding process later. By outlining the architecture, responsibilities of each class, and interactions between components, I avoided confusion and ensured that the implementation phase had a clear roadmap.

# What I Would Revise
If I could revise one part of my documentation, I would improve the non-functional requirements section by adding more detail on performance testing and long-term scalability considerations. This would make the document stronger for real-world use, where systems often grow beyond their initial scope.

# Interpreting User Needs
I interpreted the user’s needs by focusing on the game experience from the player’s perspective. Ensuring that teams and players were uniquely identified and managed prevented conflicts that could ruin gameplay. Considering the user’s needs is vital because software is only successful if it provides a smooth, reliable, and enjoyable experience for its intended audience.

# Approach to Software Design
My approach combined object-oriented design principles with design patterns to enforce structure and maintainability. I considered trade-offs between different design choices and selected solutions that balanced simplicity, scalability, and reliability.
In the future, I would continue using:
Design patterns (e.g., Singleton, Iterator) for clarity and reusability.
User-centered design thinking to keep requirements aligned with actual user needs.
Incremental refinement of design documents to continuously improve before coding.
